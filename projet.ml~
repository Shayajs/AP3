#load "clist.cmo";;
#load "ctree.cmo";;
#load "cnavl.cmo";;

open Ctree;;     
open Clist;;
open Cnavl;;

(*****     ARBRE BINAIRE DE RECHERCHE    *****)

(* 1.1 *)

(* créer un ABR aléatoire *)
let rec bst_rnd_create(n) : 'a t_btree =
  if n = 0
  then Vide
  else (bst_lbuild (list_rnd_create(n-1)))
;;

(* 1.2 *)

(* Expérimentation de déquilibre des ABR contruits à partir de suites de nombres entiers aléatoires *)
let experimentation_2(t) : unit  =
  let suite : 'a list ref = ref [] in
  let i : int ref = ref 0 in
  let count : int ref = ref 0 in
  
  print_endline("Tableau de déqulibres des arbres binaires de recherche contruits à partir de suites de nombres entiers aléatoires: ");
  print_newline();
  
  while (!i) < 100  do(
    let bt : 'a t_btree = (bst_rnd_create t) in
  let deseq : int = (ab_desequilibre bt) in
  print_int(deseq);
  suite := (add_fst (!suite) deseq);
  i:=(!i)+1;
  count := (!count) + 1;

  if (!count) = 10 then (
      print_newline ();
      count := 0;
   )
) done;

let size : int = len(!suite) in
let total : int ref = ref 0 in
while not(isempty(!suite)) do(
  total := (!total)+(fst (!suite));
  suite := (rem_fst (!suite));
)done;
    print_newline();
    print_string("total: ");
    print_int(!total);
    print_newline();
    print_string("size: ");
    print_int(size);
    print_newline();
    print_string("resultat: ");
    print_int((!total)/size)
;;

(* 1.3 *)

(* Expérimentation de déqulibres des arbres binaires de recherche contruits à partir de suites ordonnés *)
let rec suite_ordonne(n, rnd : int * int) : 'a list =
  if n = 0
  then []
  else (add_lst (suite_ordonne(n-1, rnd)) (rnd+n))
;;

let generate_n_suite(n,t : int * int) : 'a list =
 let size : int ref = ref (n+1+Random.int(5)) in
 let count : int ref = ref n in
 let newList : 'a list ref = ref [] in
 while (!count) <> 0 do(
   let suite : 'a list = suite_ordonne(!size, Random.int(20)) in
   newList := (!newList)@suite;
   count := !count -1;
   if t == 0 then ()
   else
     if t == 1
        then size := Random.int(5)
              else if t == 2
                      then size := (!size)+1
                                   else size := (!size)-1
 )
done;
 !newList
;;

let experimentation_3(t : int) : unit  =
  let suite : 'a list ref = ref [] in
  let i : int ref = ref 0 in
  let count : int ref = ref 0 in
  
  print_endline("Tableau de déqulibres des arbres binaires de recherche contruits à partir de suites ordonnés: ");
  print_newline();
  
  while (!i) < 100  do(
  let ls : int list = generate_n_suite(5, t) in
  let bt : 'a t_btree = (bst_lbuild ls) in
  let deseq : int = (ab_desequilibre bt) in
  print_int(deseq);
  print_char(' ');
  suite := (add_fst (!suite) deseq);
  i:=(!i)+1;
  count := (!count) + 1;

  if (!count) = 10 then (
      print_newline ();
      count := 0;
   )
  ) done;

  let size : int = (len (!suite)) in
  let total : int ref = ref 0 in
   while not(isempty (!suite)) do(
      total := (!total)+(fst (!suite));
      suite := (rem_fst (!suite));
    )done;
    print_newline();
    print_string("total: ");
    print_int(!total);
    print_newline();
    print_string("size: ");
    print_int(size);
    print_newline();
    print_string("resultat: ");
    print_int((!total)/size)
;;



(*******      ARBRE AVL     *********)

(* 2.1.1 *)

(* Rotations à partir des axiomes et des exemples fournis *)

(* Rotation gauche *)
let ab_rg( a : 'a t_btree) : 'a t_btree =
  match a with
    Vide -> failwith ("Erreur")
  |B_RT(_,_,Vide) -> failwith ("Erreur")
  |B_RT(p, u, B_RT(q,v,w)) -> B_RT(q, B_RT(p,u,v), w)
;;

(* Rotaiton droite *)
let ab_rd( a : 'a t_btree) : 'a t_btree =
  match a with
    Vide -> failwith ("Erreur")
  |B_RT(_, Vide, _) -> failwith ("Erreur")
  |B_RT(q, B_RT(p,u,v), w) -> B_RT(p, u, B_RT(q,v,w))
;;

(* Rotaition gauche droit *)
let ab_rgd( a : 'a t_btree) : 'a t_btree =
  match a with
    Vide -> failwith ("Erreur")
  |B_RT(_,Vide,_) -> failwith ("Erreur")
  |B_RT(_,B_RT(_,_,Vide),_) -> failwith ("Erreur")
  |B_RT(r, B_RT(p,t,B_RT(q,u,v)),w) -> B_RT(q, B_RT(p,t,u), B_RT(r,v,w))
;;

(* Rotaiton droite gauche *)
let ab_rdg( a : 'a t_btree) : 'a t_btree =
  match a with
    Vide -> failwith ("Erreur")
  |B_RT(_,_,Vide) -> failwith ("Erreur")
  |B_RT(_,_,B_RT(_,Vide,_)) -> failwith ("Erreur")
  |B_RT(r, t, B_RT(p,B_RT(q,u,v),w)) -> B_RT(q, B_RT(r,t,u), B_RT(p,v,w))
;;


(* 2.1.2 *)
                     (* dans fichier cnavl.ml *)
(* 2.1.3 *)

(*  2.2.2  *)


let rec avg_rotations(t: 'a avl_tree): unit =
  match t with
  | Empty -> 0
  | Node(_, g, d, rotations) ->
    let left_avg = avg_rotations(g) in
    let right_avg = avg_rotations (d) in
    (left_avg + right_avg + rotations)
;;

let experimentation_RT(n: int) : unit =
  let suite : 'a list ref = ref[] in
  let i : int ref = ref 0 in
  while (!i) < 1000 do
    (
  let ls = generate_n_suite(5, n) in
  let bt : 'a avl_tree = avl_linsert(ls) in
  let rotations = avg_rotations (bt) in
  print_int(rotations);
  print_char(' ');
  suite := add_fst(!suite,rotations);
  i:=(!i)+1;
  
    ) done;
 let size : int = len(!suite) in
 let total = ref 0 in
 while not(isempty(!suite)) do
   (
   total := (!total)+fst(!suite);
   suite := rem_fst(!suite);
    )done;
    print_newline();
    print_string("total: ");
    print_int(!total);
    print_newline();
    print_string("size: ");
    print_int(size);
    print_newline();
    print_string("resultat: ");
    print_int((!total)/size)
;;
